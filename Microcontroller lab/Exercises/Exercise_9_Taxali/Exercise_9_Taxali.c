/**************************Master Mind Game********************************/
/*
 Microcontroller Techniques Laboratory
 Exercise - 09
 Submitted By: Vanshaj Taxali
 Matriculation No: 4558621

 This exercise I did together with Mr. Shantam Gupta from group 5.

 Master Mind game project only on one board

 ************************** Connections*********************************

 Connect K4(LED Gn) to P1.0
 Connect K3(LED Rt) to P3.3
 Connect Heater Pin(Blue LED) to P1.4
 Connect Yellow LED on JP3 to P1.5
 Connect X1 Buzzer Pin to P3.6
 Connect PB5 to P1.3

 ************************** RULES OF THE GAME***************************
 /*
 * We have modified the rules of the game a bit and it is not just a brain game it is also the test of your visual capabilities, the player
 * must have a very good visual memory to record the feedback of your code and remember the feedback sequence and compare it with his own
 * sequence.
 *
 * 1)When the controller starts, it will generate a random 4 digit code from 1-4 and after that Green led (D5) will blink and will become
 * stable indicating the board is ready to start the game.
 *
 * WARNING: DO NOT PRESS THE BUTTONS WHILE THE GREEN LED IS BLINKING. DO IT ONLY AFTER IT STOPS.
 *
 * 2) All the buttons from PB1-PB4 represent nos. 1,2,3,4 respectively and after each press "RED" LED (D6) will glow indicating
 * that your number has been stored, and the user must do this only 4 times to feed a 4 digit sequence.
 * For example, if one presses PB2-PB3-PB1-PB4 a sequence of 2-3-1-4 is stored on the board.
 *
 * 3) So What's new?? Well, once you enter your code, it is compared to the random code generated by the controller and the correct positions
 * will glow respectively.
 * For example, entered code is 2-3-1-4 and the random code generated is 2-1-2-4.
 * Then, D1 LED will glow followed by D4 indicating that code at positions 1 and 4 were correct.
 *
 * 4)There are only 4 chances to guess the code. If you guess the code within 4 trials, a winning tone will be played and all LEDs will glow
 * on the board. After that the new game will start.
 * Alternatively, if you could not guess the code correctly within the 4 trials, a loosing tune will be played and the game will start new.
 *
 * 5)Please be gentle while pressing the buttons as it can generate some error sequence and cause aberrations.
 * If at any point that happens press PB5 to restart the game with a new random code.
 *
 * NOTE: For test purposes you can turn on HTERM to see the random code generated by u-controller
 *
 *
 * Since most of the concepts were already explained in all the previous exercises, only the new functions are explained here.
 */

/**************************************Header files*********************/

#include <msp430.h>
#include <templateEMP.h>
#include <stdlib.h>
#include <time.h>

/*******************************DEFINATIONS FOR BUZZER TUNES*********************/

#define f 2863
#define g 2551
#define a 2273
#define b 2028
#define c5 1912

/*******************************INITIALIZING GLOBAL VARIABLES*********************/
int x, z, s, r, j, total;
int count;

int win[];
int gencode[4];
int PB1, PB2, PB3, PB4;
int code[4];

// ++++++++++++++++++++++++++
// ++ FUNCTION DECLARATION ++
// ++++++++++++++++++++++++++

void initial();         // function to initialize the port and pins
void enableinterrupt(); // function to enable interrupt via PB5
void randomcode();      // function to generate random code


/********************BUZZER FUNCTIONS********************/

void play(int tone, int duration); // function to play the tune
void tune1();                      // function to play the winning tune
void tune2();                      // function to play the loosing tune


/***************SHIFT REGISTER FUNCTIONS**********************/

void clck(int x);   // function to generate clck with x as an argument and it decides number of clcks
void rshift1();     // function to set right shift direction of the data in register 1
void rshift2();     // function to set right shift direction of the data in register 2
void lshift2();     // function to set left shift direction of the data in register 2
void clreg();       // function to clear the shift register


/***********Functions to control LED and Buttons****************/

void ledglow(int d);
void shiftButtons();
void readButtons();
void holdvalue();       // Holds the value given to LED or buttons
void assignbutton();


// +++++++++++++++++++
// ++ MAIN FUNCTION ++
// +++++++++++++++++++

int main(void)
{
    initMSP();
    initial();
    while (1)
    {

        int i;
        i = 1;

        enableinterrupt();
        clreg();
        randomcode();

        for (j = 1; j <= 10; j++)
        {

            P1OUT |= BIT0;
            __delay_cycles(125000);
            P1OUT &= ~BIT0;
            __delay_cycles(125000);
        }
        P1OUT |= BIT0;

        for (total = 1; total <= 4; total++)
        {

            clreg();

            i = 1;
            for (r = 1; r <= 4; r++)
            {

                gencode[r] = 0;
                win[r] = 0;
            }

            while (i <= 4)
            {
                while (z == 0)
                {
                    assignbutton();
                }

                P3OUT |= BIT3;
                __delay_cycles(250000);
                P3OUT &= ~BIT3;

                gencode[i] = z;
                z = 0;

                i++;
                clreg();
            }

            count = 0;
            if (gencode[1] == code[1])
            {
                ledglow(1);

                holdvalue();
                win[1] = 1;

            }

            if (gencode[2] == code[2])
            {
                ledglow(2);
                win[2] = 1;
                holdvalue();

            }
            if (gencode[3] == code[3])
            {
                ledglow(3);
                win[3] = 1;
                holdvalue();

            }
            if (gencode[4] == code[4])
            {
                ledglow(4);
                win[4] = 1;
                holdvalue();
                if (win[1] == 1 && win[2] == 1 && win[3] == 1 && win[4] == 1)
                {

                    ledglow(0);
                    holdvalue();
                    P1OUT |= BIT0;
                    __delay_cycles(250000);
                    P1OUT &= ~BIT0;
                    P3OUT |= BIT3;
                    __delay_cycles(250000);
                    P3OUT &= ~BIT3;
                    P1OUT |= BIT4;
                    __delay_cycles(250000);
                    P1OUT &= ~BIT4;
                    __delay_cycles(250000);
                    tune1();
                    P1OUT |= BIT0;
                    P3OUT |= BIT3;
                    P1OUT |= BIT4;
                    P1OUT |= BIT5;
                    __delay_cycles(3000000);

                    WDTCTL = 0;

                }

            }

        }
        tune2();
        WDTCTL = 0;
    }
}


// +++++++++++++++++++++++++
// ++ FUNCTION DEFINITION ++
//++++++++++++++++++++++++++

void initial()
{
    P2SEL = 0;
    P2SEL2 = 0;

    P2DIR |= BIT0 + BIT1 + BIT2 + BIT3 + BIT4 + BIT5 + BIT6;
    P2DIR &= ~BIT7;
    P1DIR |= BIT0 + BIT3 + BIT4 + BIT5;
    P1OUT &= ~(BIT0 + BIT3 + BIT4 + BIT5);
    P3OUT = 0x00;
    P3SEL = 0x00;
    P3SEL2 = 0x00;

    P3DIR |= BIT6 + BIT3;
    P3SEL |= BIT6;

    TA0CCTL0 = OUTMOD_4;
    TA0CCTL2 = OUTMOD_3;

    TA0CCR0 = 0x00;
    TA0CCR2 = 0x00;

    TA0CTL = TASSEL_2 + MC_1;

}

void enableinterrupt()
{
    P1DIR &= ~BIT3;
    P1REN |= BIT3;
    P1OUT |= BIT3;

    P1IES &= ~BIT3;
    P1IFG = 1;
    P1IE |= BIT3;
}

void randomcode()
{
    srand(time(NULL));              //required for "randomness"

    for (r = 1; r <= 4; r++)
    {
        code[r] = rand() % 4 + 1;   //generate a number between 0 and 5

        if (code[r] == 0)
        {
            code[r] = 1;
        }

    }

    for (r = 1; r <= 4; r++)
    {
        serialPrintInt(code[r]);
    }
}

void play(int tone, int duration)
{
    int t;

    TA0CCR0 = tone;
    TA0CCR2 = tone / 2;

    for (t = 0; t < duration; t++)
    {
        _delay_cycles(1000);
    }
}

void tune1()
{
    int t;

    int tone[] = { f, g, a, f, g, a };

    int duration[] = { 200, 200, 200, 200, 200, 200 };

    for (t = 0; t <= 5; t++)
    {
        play(tone[t], duration[t]);
        TA0CCR0 = 0;
        TA0CCR2 = 0;
        _delay_cycles(150000);
    }

    TA0CCR0 = 0;
    TA0CCR2 = 0;
}

void tune2()
{
    int t;

    int tone[] = { a, b, c5, a, b, c5 };

    int duration[] = { 300, 300, 300, 300, 300, 300 };

    for (t = 0; t < 5; t++)
    {
        play(tone[t], duration[t]);
        TA0CCR0 = 0;
        TA0CCR2 = 0;
        _delay_cycles(150000);
    }

    TA0CCR0 = 0;
    TA0CCR2 = 0;
}

void clck(int x)        //function to generate clock with x as an argument and it decides number of clocks
{
    while (x > 0)
    {
        P2OUT |= BIT4;
        P2OUT &= ~BIT4;
        x--;
    }
}

void rshift1()          // function to set right shift direction of the data in register 1
{
    P2OUT |= BIT2;
    P2OUT &= ~BIT3;
}

void rshift2()          // function to set right shift direction of the data in register 2
{
    P2OUT |= BIT0;
    P2OUT &= ~BIT1;
}

void lshift2()          // function to set left shift direction of the data in register 2
{
    P2OUT |= BIT1;
    P2OUT &= ~BIT0;

}

void clreg()            // function to clear the shift register
{
    P2OUT &= ~BIT5;
    P2OUT |= BIT5;
}

void ledglow(int d)
{
    clreg();
    if (d == 0)
    {
        P2OUT |= BIT6;
        rshift2();
        clck(4);
    }
    if (d == 1)
    {
        P2OUT |= BIT6;
        rshift2();
        clck(1);
    }
    else if (d == 2)
    {
        P2OUT |= BIT6;
        rshift2();
        clck(1);
        P2OUT &= ~BIT6;
        clck(1);
    }
    else if (d == 3)
    {
        P2OUT |= BIT6;
        rshift2();
        clck(1);
        P2OUT &= ~BIT6;
        clck(2);
    }
    else if (d == 4)
    {
        P2OUT |= BIT6;
        rshift2();
        clck(1);
        P2OUT &= ~BIT6;
        __delay_cycles(100);
        clck(3);
    }

}

void shiftButtons()
{
    P2OUT &= ~BIT3;
    clck(1);
}

void readButtons()
{
    s = 1;
    while (s > 0)
    {
        P2OUT |= BIT2 + BIT3;
        P2OUT &= ~(BIT0 + BIT1);
        clck(1);
        PB4 = P2IN & BIT7;
        shiftButtons();
        PB3 = P2IN & BIT7;
        shiftButtons();
        PB2 = P2IN & BIT7;
        shiftButtons();
        PB1 = P2IN & BIT7;
        s--;
    }
}

void holdvalue()            // Function with a manual while loop counter to hold the state of the LEDs D1 to D4 or buttons
{
    while (count < 30000)
    {
        count++;
    }
    count = 0;
}

void assignbutton()
{
    x = 1;
    while (x > 0)
    {
        z = 0;
        readButtons();

        if (PB1)
        {
            z = 1;
        }
        if (PB2)
        {
            z = 2;
        }
        if (PB3)
        {
            z = 3;
        }
        if (PB4)
        {
            z = 4;
        }
        x--;
    }
}


// +++++++++++++++++++++++++++++++
// ++ INTERRUPT SERVICE ROUTINE ++
// +++++++++++++++++++++++++++++++

#pragma vector=PORT1_VECTOR
__interrupt void Port_1()
{
    P1IE &= ~BIT3;            //Switch off the Interrupt

    WDTCTL = 0;

    P1IE |= BIT3;             //Activate Interrupt again
    P1IFG &= ~BIT3;
}
